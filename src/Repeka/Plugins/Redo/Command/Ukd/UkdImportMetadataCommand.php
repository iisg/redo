<?php
namespace Repeka\Plugins\Redo\Command\Ukd;

use Assert\Assertion;
use Doctrine\ORM\EntityManagerInterface;
use Repeka\Application\Cqrs\CommandBusAware;
use Repeka\Domain\Entity\ResourceEntity;
use Repeka\Domain\Repository\MetadataRepository;
use Repeka\Domain\Repository\ResourceKindRepository;
use Repeka\Domain\Repository\ResourceRepository;
use Repeka\Domain\UseCase\Resource\ResourceListQuery;
use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Helper\ProgressBar;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class UkdImportMetadataCommand extends ContainerAwareCommand {
    use CommandBusAware;
    /** @var ResourceKindRepository */
    private $resourceKindRepository;
    /** @var ResourceRepository */
    private $resourceRepository;
    /** @var MetadataRepository */
    private $metadataRepository;
    /** @var EntityManagerInterface */
    private $entityManager;

    public function __construct(
        ResourceKindRepository $resourceKindRepository,
        ResourceRepository $resourceRepository,
        MetadataRepository $metadataRepository,
        EntityManagerInterface $entityManager
    ) {
        parent::__construct();
        $this->resourceKindRepository = $resourceKindRepository;
        $this->resourceRepository = $resourceRepository;
        $this->metadataRepository = $metadataRepository;
        $this->entityManager = $entityManager;
    }

    protected function configure() {
        $this->setName('redo:ukd:import')
            ->addOption(
                'file',
                'f',
                InputOption::VALUE_REQUIRED,
                'File with mapping generated by redo:ukd:match command)'
            )
            ->addOption(
                'resourceKind',
                'r',
                InputOption::VALUE_REQUIRED,
                'Resources of this kind will have links imported. Specified by ID or name.'
            )
            ->addOption('metadata', 'm', InputOption::VALUE_REQUIRED, 'Metadata to match mapping against')
            ->addOption('keyword', 'k', InputOption::VALUE_REQUIRED, 'Keyword metadata name to import into')
            ->addOption('link', 'l', InputOption::VALUE_OPTIONAL, 'Link submetadata name, keyword should its be parent')
            ->addOption('offset', null, InputOption::VALUE_REQUIRED, '', 0)
            ->addOption('limit', null, InputOption::VALUE_REQUIRED, '', 1000)
            ->setDescription('Import key-link pairs into specified metadata.');
    }

    protected function execute(InputInterface $input, OutputInterface $output) {
        Assertion::notEmpty($input->getOption('file'), 'Please specify file containing keywords mapped to links.');
        Assertion::notEmpty($input->getOption('resourceKind'), 'Please specify resource kind using name or id.');
        Assertion::notEmpty($input->getOption('metadata'), 'Please specify metadata from which keywords will be extracted.');
        Assertion::notEmpty($input->getOption('keyword'), 'Please specify metadata to insert keywords into.');
        Assertion::notEmpty($input->getOption('link'), 'Please specify submetadata to insert links into.');
        $resources = $this->getResourcesByResourceKind(
            $input->getOption('resourceKind'),
            $input->getOption('limit'),
            $input->getOption('offset')
        );
        $sourceMetadataId = $this->getMetadataId($input->getOption('metadata'));
        $keywordMetadataId = $this->getMetadataId($input->getOption('keyword'));
        $linkSubmetadataId = $this->getMetadataId($input->getOption('link'));
        $mappingFilename = $input->getOption('file');
        $mappings = json_decode(file_get_contents($mappingFilename), true)['ukd_tags'];
        $progressBar = new ProgressBar($output, count($resources));
        foreach ($resources as $resource) {
            $contents = $resource->getContents();
            $sourceValues = $resource->getContents()->getValues($sourceMetadataId);
            $keywordContents = [];
            foreach ($sourceValues as $sourceValue) {
                $keywords = explode('.', $sourceValue->getValue());
                foreach ($keywords as $keyword) {
                    $keyword = trim($keyword);
                    if (empty($keyword)) {
                        continue;
                    }
                    $link = $mappings[$keyword] ?? null;
                    if ($link) {
                        $keywordContents[] = ["value" => $keyword, "submetadata" => [$linkSubmetadataId => [$link]]];
                    }
                }
            }
            $updatedContents = $contents->withMergedValues($keywordMetadataId, $keywordContents)->clearDuplicates($keywordMetadataId);
            $resource->updateContents($updatedContents);
            $this->resourceRepository->save($resource);
            $progressBar->advance();
        }
        $this->entityManager->flush();
    }

    /** @return ResourceEntity[] */
    private function getResourcesByResourceKind($resourceKindNameOrId, $limit, $offset) {
        $resourceKind = $this->resourceKindRepository->findByNameOrId($resourceKindNameOrId);
        $resourceQuery = ResourceListQuery::builder()
            ->filterByResourceKind($resourceKind)
            ->setPage(($offset / $limit) + 1)
            ->setResultsPerPage($limit)
            ->build();
        return $this->resourceRepository->findByQuery($resourceQuery)->getResults();
    }

    private function getMetadataId($nameOrId) {
        return $this->metadataRepository->findByNameOrId($nameOrId)->getId();
    }
}
